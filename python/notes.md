- [#[스택]](#[스택])
- [#[큐]](#[큐])
***

[14기]
- 1차
1) 구현
2) Brute Force/BackTracking/DFS/BFS
3) 조합, BFS
4) BFS (그리디)
5) SQL - 문자열(정규식)

- 2차
1) 스택
2) 그리디, 시뮬레이션
3) 구현, deque
4) 다익스트라/플로이드워셜
5) SQL - JOIN, UNION ALL


---

[13기]
- 1차
1) 구현
2) 빡구현
3) 조합
4) 정렬, 인덱싱
5) DFS

- 2차
1) 구현
2) brute force
3) Union-Find, BFS, DFS
4) DP


---

[12기]
- 1차
1) DFS
2) BRUTE FORCE
3) 투포인터
4) 구현
5) 분할정복
6) DP
7) 그리디

- 2차
1) DFS/BFS
2) 분할정복
3) 재귀


---

[11기]
- 1차
1) 구현
2) 그리디
3) BFUTE FORCE
4) BFS

- 2차
1) DP
2) BFS/DFS
3) UNION-FIND
4) 라인 스위핑
5) BRUTE FORCE
6) 정렬

***

최소한 기출된 모든 알고리즘은 구현 가능해야 함
+) 이분탐색?
+) MST(최소 신장 트리)?


***

[전략]
- 문제 푸는 시간 제한이 있기에 5번 먼저 풀고, 알고리즘 중 쉬운 거 먼저. 풀 문제 버릴 문제 잘 골라야 함.
- 문제 꼭 요약하고 정리하기. 조건 제발 꼼꼼히 보자. 예시 꼼꼼히 보기. SQL도 마찬가지.
- 어떤 알고리즘 사용할지 생각해보기
- 특히 n=1인 경우 등에 대해 테스트 케이스 꼭 추가로 만들기
- n=1인 경우에 대해서는 잘 생각하고 있어. 다만 "최댓값"에 대해 정확히 조사하자!!!! 이거 때문에 틀린 문제 '다리를 지나는 트럭'
- => 개선법. 미리 정해놓는 리스트의 크기를 변수값을 활용해서!
- 시간복잡도 제한은 빡빡하지 않은 편이므로 10초도 괜찮다 생각하고 정확하게 안전하게 구현하기!!
- 한 문제를 풀더라도 제대로 풀자! 이렇게 풀었는데 시간이 부족하다면 내가 부족한거다! 그렇다면 시간을 줄일 다른 방법을 찾아야 하는 거지! 문제 하나를 꼼꼼하지 않게 푼다고 되는 게 아니다!
- ⭐️ 중간에 break가 되는 경우, 따로 bool형 변수를 둬서 False인 경우 무조건 ans을 0으로 주는 코드를 추가하는 걸 고려하자
- 변수명은 가급적이면 중복적이게 쓰지 말자! 혹시 모르는 실수 발생을 방지하기 위해!
  컴파일러가 못 걸러준다. 단순 for문이더라도!
- 중첩 반복문 쓸 때 반복문 변수 주의하기
- 구현 코드가 길어질수록 변수 오타 없는지 여러 번!! 꼼꼼히 확인할 것

***

푼 문제
프로그래머스 고득점 kit 
백준 단계별

***

### [스택]
- 괄호 문제
- 키로거 문제
- 오큰수 
- * for문 돌리는 중간에 stack이 빌 수도 있으니까, stack이 비었을 경우에 입력한다는 조건 꼭 고려하기
https://school.programmers.co.kr/learn/courses/30/lessons/42584
=> 여기 있는 거 추후에 다시 보고 메모할 거 하기
- https://www.acmicpc.net/problem/10799 (풀이, 코드 한 번 간단히 보기)
- https://www.acmicpc.net/problem/1406

***

### [큐]
- 선입 선출 => 큐 생각하기!

***

### [연결리스트]

- 파이썬에서 연결리스트는 c언어처럼 직접 구현해줘야 한다. 
  따라서 시간이 소모될 수 있음을 고려해서 우선순위를 낮추든지 해야 할 듯
- 연결리스트에서 전체 순회는 while을 이용한다. 전체 길이를 알기 위해선 모두 순회를 해야하기 때문임
~~~
class Node:
    def __init__(self, val=0, next=None):
        self.val=val
        self.next=next
    
    def findOrDisplay(self, head):
        current = head  # 연결 리스트의 시작점
        while current is not None:
            # 현재 노드의 데이터 처리
            print(current.value)
            # 다음 노드로 이동
            current = current.next

head = Node(0)
nextNode = Node(1)
head.next=nextNode
~~~

***

### [해시]

- set 사용하여 중복 제거
- https://www.acmicpc.net/problem/1269
  - => set는 진짜 집합처럼 서로 빼기 가능함ㄷㄷ
***

### [조합]


***

### [Union-Find(분리 집합)]

분리 집합 :  분리된 집합
Union-Find : 분리된 집합 간의 합집합(Union)과 특정 원소가 속한 집합을 찾는(Find) 연산

⭐️ 코드 이해를 기반으로 외우기!!
아래 코드는, "x의 부모를 찾음과 동시에 지나가는 모든 길에서의 부모도 업데이트"
~~~
def find(x):
  if Vroot[x]!=x:
    Vroot[x] = find(Vroot[x])
  return Vroot[x]
~~~

- 노드 개수가 작은 경우에 그래프 탐색(bfs/dfs)로도 풀리는데,
  union-find로 제출된 문제는 이게 훨씬 쉬우니 이걸로 푸는 게 좋을 듯

- https://www.acmicpc.net/problem/20040 (유니온 파인드로만 풀 수 있는 문제! == 유니온 파인드임을 알면 쉬운 문제, 모르면 못푸는 문제)

- 친구의 친구는 친구다
- 같은 집합에 속하는 개수 세기
- 같은 집합에 속하는지 찾기

-  시사점) A-B, C-D-E-F, 그리고 B-F가 있을 때, A-B-F가 먼저 A를 부모로 이어지고,  C-D-E가 C를 부모로 여겨졌을 때, E-F연결에 대해
   해당 반례! [[1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0], [0, 0, 0, 1, 1, 1], [0, 1, 0, 0, 1, 1]]
   [0, 0, 2, 3, 4, 5]
   [0, 0, 2, 3, 4, 0]
   [0, 0, 2, 2, 4, 0]
   [0, 0, 2, 2, 2, 0]
   [2, 0, 2, 2, 2, 0] ⭐️ E-F연결에 대해 F의 부모는 현재 A이다. 그럼 업데이트 되는 것은 vRoot[F]가 아니라 vRoot[A]다!!!!!
   [2, 2, 2, 2, 2, 2]

- ⭐ 역시 마지막에 union-find 한 번 돌면서 다시 통합 해줘야한다!!!!
  유니온 파인드(Union-Find) 알고리즘에서 마지막에 모든 노드에 대해 부모 노드를 업데이트하는 과정은 "경로 압축(Path Compression)"이라는 기법의 일부입니다.
  이 과정을 거치는 주된 이유는 유니온 파인드의 두 주요 연산인 `find`와 `union`의 효율성을 높이기 위함입니다.
유니온 파인드 알고리즘의 목적은 집합의 표현과 두 요소가 같은 집합에 속하는지 빠르게 확인(즉, `find` 연산) 및 두 집합을 합치는(`union` 연산) 것입니다.
  초기에는 모든 요소가 자신만의 집합을 형성하며, 이후 연산을 통해 점차 집합들이 합쳐집니다.
  경로 압축(Path Compression)
 : `find` 함수가 호출될 때, 경로 압축 기법은 찾고자 하는 노드에서 최상위 부모(즉, 루트 노드)까지 가는 경로에 있는 모든 노드의 부모를 최상위 부모로 직접 연결합니다. 
이렇게 하면 다음에 같은 노드를 찾을 때, 루트 노드까지 가는 경로가 대폭 단축되어 `find` 연산의 시간 복잡도가 개선됩니다.




***

### [정렬]

정렬은 그리디랑 같이 등장하는 경우가 많나? 나중에 확인할 것

***

### [그래프 탐색]

- dfs
  - 재귀함수 제한이 기본 1000임
  - import sys
  - sys.setrecursionlimit(10**5)
  - 프로그래머스 환경에서도 설정 필요
  - 최악의 경우 대충 노드 개수만큼의 재귀 깊이가 발생할 수 있음
  - 당연히, 데이터에 따라 달라짐
  - 그리고 재귀 깊이를 너무 크게하면 메모리 초과가 발생할 수 있기에, 적절한 수치를 찾아야함

- bfs
  -  dfs, bfs 둘 다 쓸 수 있으 bfs가 나은 것 같기도?
  - https://www.acmicpc.net/problem/13549 
    -  bfs는 모든 간선의 가중치가 같은 경우에만 가능하다.
    - visited를 쓰기 때문이다. 
    - 그냥 

***

### [MST]

[ 최소 신장 트리 (minimum spanning tree, MST) ]

최소 신장 트리 : 주어진 그래프의 모든 정점들을 연결하는 부분 그래프 중에서 가중치의 합이 최소인 트리

구하는 방법은 크게 3가지가 있다.

1) 크루스칼(Kruscal) : 가장 대중적인 방법

2) 프림(Prim)

3) 다익스트라(Dijkstra)
   (모든 다익스트라가 MST라는 게 아니라, MST를 구하는 방법 중 다익스트라가 있는 것)

### [크루스칼 알고리즘]

: 크루스칼 알고리즘은 '그리디' 알고리즘의 일종이다.  MST를 구현하는 대표적인 방법이다.



1) 가중치 기준으로 오름차순 정렬

2) 정렬된 순서대로, 앞에서부터 선택하여 두 정점을 이어줌. (연결했다면 weight를 담아준다)

3) 선택할 때, 만약 사이클이 형성된다면, 선택하지 않음 (사이클이 형성된다는 것은, 이미 선택하려는 간선의 두 정점이 ★같은 집합★에 있다(=★같은 집합은 같은 root이도록 표시함★)라는 것
=> Union-Find 사용

4) 모든 간선에 대해 2,3번을 반복한다!
~~~
v, e = map(int, input().split()) #v는 1부터 v까지 정점 번호, e는 간선 개수
Glist = [] #그래프 정보를 담아줄 리스트
for i in range(e): #그래프 정보(간선,가중치) 입력받아서 Elist에 저장
    a,b,c=map(int, input().split())
    Glist.append([c,a,b]) #sort를 위해 가중치를 맨 앞에

Glist.sort() #★가중치 기준으로 정렬 ⭐
#print(Glist)

def find(x): #★진짜 부모를 찾아 update하고 반환해주는 함수!
    if x!=Vroot[x]: #자기 자신이 root이면 그냥 자기 자신 정점을 루트로서 반환해주고, ★그렇지 않다면 '재귀'를 통해 진짜루트를 찾아서 반환한다. 
        Vroot[x]=find(Vroot[x])  #따로 따로 만들어지고, 나중에 합쳐지는 경우에 큰 집합 2개가 1개로 연결되어 부모 update해줄 일이 있다. 
        #부모를 찾는 동시에, 재귀를 이용하여 update까지 함(최적화)
    return Vroot[x] 

Vroot = [i for i in range(v+1)] #각 정점의 root를 담아주는 리스트. ★root가 같다면, 같은 집합이다!★
#초기값은 정점 자기 자신 번호로(자기 자신이 root라 가정=★자기 자신만 담긴 집합 1개씩으로 배정★) 

ans=0
for w,a,b in Glist: #* ⭐ 2차원 리스트 값 편하게 꺼내 쓰는 방법, 모든 간선에 대해 검사. 
    #print(a,b,w) #2차원 리스트 요소 하나하나 꺼내져 나옴
    #print("시작",Vroot)
    aRoot=find(a) #간선으로 이어진 두 정점의 '진짜' root를 구한다.  
    bRoot=find(b)
    #print(aRoot,bRoot,'a',Vroot)
    if aRoot!=bRoot:  #서로 다른 root를 가지고 있다면(=서로 다른 집합에 속한다), 둘 중 하나의 집합을 탈락시키고 나머지 하나의 집합으로 편입된다.
        Vroot[bRoot]=aRoot #그냥 a번 정점을 root로 차곡차곡 담기. 
        ans+=w #간선 선택했으니까 weight 담기
    #print(Vroot)
    #print()
print(ans)
~~~

***

### [다익스트라]
- k번 정점부터 모든 정점까지의 각 최소거리.
- 더 효율적인 탐색을 위해 "힙"을 사용
- 다익스트라는 크루스칼과 다르다! 힙을 사용하는게, 크루스칼처럼 시작점 무관 최소값을 구하는 게 아니라,
  ⭐ 시작점에서부터 이어지는 경로의 최소값을 구하는 것이다!
- ⭐ heapq는 기본적으로 작은 값을 먼저 뽑는다. 
  - 큰 걸 먼저 뽑게 하고 싶으면 마이너스 값을 넣으면 된다
- ⭐ 다익스트라로는 최대경로(A-B-C든 A-C든, A->C를 위해 거치는 모든 경로들의 비용합)를 구할 수 없다!! 
  다익스트라는 최소 비용 경로를 구하기 위한 알고리즘이다. 
  * 최대경로를 구하기 위해 더 큰 값을 dp에 담는다면, 계속해서 사이클을 돌며 더 많은 경로를 담으면 되니까 무한에서 빠져나오지 못한다
  * 이럴 경우 다른 알고리즘을 생각하는 게 백번 옳다
- ※ 노드는 총 1만개, 간선은 10만개로, 만약 graph[a][b]=c처럼 2차원 graph를 미리 다 만들어둔다면, 1억개의 칸이 생겨 메모리 초과가 발생한다!
  -  입력된 간선과 가중치를 graph[a].append((b,c))로 입력된 간선들만 담아준다.
- 플로이드 워셜과 비교하면, 다익스트라는 시작점이 고정되어있고, 플로이드 워셜은 모든 정점에서 모든 정점까지의 최소비용을 구한다. 
- 다익스트라가 은근히.. 어려운 듯
- 반대로, "모든 정점에서 특정 노드x로 도착하는 경우"에도, "그래프만 뒤집은 뒤 다익스트라"로 최소 비용 경로 구할 수 있다!

~~~
import sys
input = sys.stdin.readline

import heapq #최솟값을 빠르게 꺼내기 위해 최소 힙써야함

v,e=map(int,input().split())
graph=[ [] for i in range(v+1)]
k=int(input()) #시작점
dp=[200001 for i in range(v+1)] #최댓값 20만
heap=[] ⭐
for i in range(e):
    a,b,c=map(int,input().split())
    graph[a].append([b,c]) 

def dijkstra(k): #시작 정점번호 k
    #시작 정점번호 넣은 상태로 시작
    dp[k]=0 
    heapq.heappush(heap,(0,k)) ⭐
    #print("시작:",(0,k),dp)

    while True: #메인
        if len(heap)==0:
            break
        weight,node=heapq.heappop(heap) #최소값 꺼냄!
        
        for next_node,next_weight in graph[node]: #현재 정점에서 연결된 모든 노드에 대해 검사! 이렇게 for문 쓰는 방법 잘 기억해두기.
            next_weight+=weight
            
            if next_weight<dp[next_node]: #dp를 업데이트 시켜주는 경우
                dp[next_node]=next_weight #시작정점 k에서부터
                heapq.heappush(heap,(next_weight,next_node))
                #print("push:",(next_weight,next_node))

        
dijkstra(k) #데이크스트라 실행
for i in range(1,v+1):
    if dp[i]==200001:
        print("INF")
    else:
        print(dp[i])
~~~

### [플로이드 워셜 Floyd-Warshall]
- 모든 정점에서 모든 정점까지의 각 최소거리
- DP의 일종. 엄연히 따지면 brute force는 아님
- n=1000인 경우에 2차원 graph 미리 만들어놓는 것 메모리 문제 없는 듯

- ⭐ 중첩 3중 for문할 때 "경유노드, 시작 노드, 도착 노드 순서대로(k,i,j, g[i][j]=g[i][k]+g[k][j])" 해야 하는 이유
  - dp이기 때문이다 .Dp의 특징을 이해한다면 당연한 것.
  - k i j 순서대로 진행될 때를 생각해보자
  - ⭐dp[start][end]를 결정하기 위해 사용되는 dp[start][intermediate], dp[intermediate][end]값은 이전 dp에 의해 확실히 결정된 상태여야 한다!!!
  - 1 1 1 (1->1, 1->1 필요) g[1][1] 결정됨
  - 1 1 2 (1->1, 1->2 필요) g[1][2] 결정됨
  - 1 1 3 (1->1, 1->3 필요) g[1][3] 결정됨
  - 1 1 4 (1->1, 1->4 필요) g[1][4] 결정됨
  - 1 2 1 (2->1, 1->1 필요) g[2][1] 결정됨
  - 1 2 2 (2->1, 1->2 필요) g[2][2] 결정됨
  - 1 2 3 (2->1, 1->3 필요) g[2][3] 결정됨
  - 1 2 4 (2->1, 1->4 필요) g[2][4] 결정됨
  - 1 3 1 (3->1, 1->1 필요) g[3][1] 결정됨
  - ... => 모든 dp가 이전에 확정된 값을 사용함!!!
  - 
  - ⭐ 그에 반해, i j k 순서대로 진행된다면 (무적권 오답) 
  - 1 1 1 (1->1, 1->1 필요) g[1][1] 결정됨
  - 1 1 2 (1->2, 2->1 필요) g[1][1] 결정됨 ⭐ 여기까지만 봐도,
      2->1의 최적의 정해진 dp값은 아직 결정되지도 않았는데, 앞으로 다시 안돌아올 1->2->1을 위해 사용하므로 절대 오답임
  - 1 1 3 (1->3, 3->1 필요) g[1][1] 결정됨 오답
  - 1 1 4 (1->4, 4->1 필요) g[1][1] 결정됨 오답
  - 1 2 1 (1->2, 1->1 필요) g[1][2] 결정됨 오답
  - 1 2 2 (1->2, 2->2 필요) g[1][2] 결정됨 오답
  - ... => 더 볼 것도 없다. k i j 순서대로 로직 짜자

- 만약 n=1000이라서 시간을 합법적이고 오류 없이 줄여주고 싶다면,
  1) dp[i][j]에 항상 min값을 대입하지 말고 작을 경우에만 업데이트 시키기
  2) dp[i][k], dp[k][j]값을 변수에 담아두기
  3) ⭐ 두 번째 for문 뒤에서, if (dp[i][k]==MAX_COST): continue 로 가지치기하기!!!
  4) n이 클 경우(n세제곱이니까 500이상도 위험할지도), MAX_COST를 무작정 sys.maxsize로 두는 것보다,
  "모든 노드 개수 * 각 간선의 가중치 + 1"을 MAX_COST로 두는 것이 시간을 절약할 수 있다.
  단, 이게 정말 max_cost가 맞는지 신중해야 한다 (문제에 따라 추가 조건이 있을 수 있으니까)

~~~
import sys
input = sys.stdin.readline


n=int(input())
m=int(input())
MAX_COST=sys.maxsize

graph = [[MAX_COST+1 for i in range(n)] for i in range(n)]

for i in range(m):
    a,b,c=map(int,input().split())
    a-=1
    b-=1
    graph[a][b]=min(c,graph[a][b])
    

for k in range(n): # ⭐ 여기가 k다!!!!
    for i in range(n):
        if (graph[i][j]==MAX_COST): # ⭐
            continue
        for j in range(n):
            graph[i][j]=min(graph[i][j], graph[i][k]+graph[k][j]) # ⭐ 

for i in range(n):
    for j in range(n):
        if graph[i][j]==MAX_COST+1:
            graph[i][j]=0

    
for i in range(n):
    graph[i][i]=0


~~~

***

[라이브러리]

⭐️ round는 내장 함수임!   
* 파이썬의 round는 특이하다. 0~4를 버리고 5~9를 올리는 사사오입 방식이 아님. 따라서 직접 구현해 쓸 것
~~~
만약 2자리 수에서 반올림하는 경우,
(3.15 - 3.1(버림 이용) >=0.05 라면 3.2(올림 이용))
(아니면 3.1(버림 이용))
=> 몇 자리 수에서 반올림하느냐에 따라 달라짐!
~~~
 
- import math
  - ceil : 올림
  - floor: 내림
  - fabs: 절대값
  - log(10,2) : log2(10)
  - sqrt(25) : 제곱근 구하기(5)

- 람다
  - max(iterable, key=lambda x:(dic[x], -x))
  - => 이렇게 여러 조건을 넣어줄 수도 있음! 
  - => dic의 key값이 큰 순으로, key값이 같다면 x가 작은 순으로 max 뽑음!!!
  - 2차원 리스트에서 2번째 값을 기준으로 최대값 구하기
    index, priot = max(dq, key=lambda x:x[1])
  - map(함수, 리스트)
    - 리스트에서 하나씩 꺼내 각각 함수를 적용시킨다
    - list(map(lambda x: x ** 2, range(5)))  
      [0, 1, 4, 9, 16]
  -  reduce(함수, 리스트)
    - 리스트에서 하나씩 꺼내서 함수 적용하고 누적시킴
    - reduce(lambda x, y: x + y, [0, 1, 2, 3, 4])
      10
    - from functools import reduce 필요!
    - 문자열 합치기를 reduce(lambda x,y:x+y,list)로 할 수 있긴 한데, 
      "".join(list)이 이미 있는지라.. 오히려 이거 쓰니까 시간초과뜸;; 확실하지 않으면 직접 구현하든지..
    - 왜냐하면 파이썬의 string도 "불변 객체"이기 때문에 매번 +=해주면 시간 문제 있을 수 있음
  - filter(함수, 리스트)
    - 리스트에서 하나씩 꺼내서 함수 적용 결과가 참인 경우에만 새로운 리스트에 담음
    - list(filter(lambda x: x < 5, range(10))) 
      [0, 1, 2, 3, 4]
  - sort(key=lambda x:len(x))
    - sort는 새로운 list를 반환하는게 아니라 기존의 리스트를 변경시킨다. 아무것도 반환하지 않는다!!!(None반환)
    - 람다로 sort도 가능! 다차원도 쉽고 빠르게 정렬 가능! 역순으로 해주고 싶다면 -만 붙여주면 됨!
    - 다차원 sort(key=lambda x:(-x[0], x[1])) 
      - => ⭐️2차원 리스트에서 0번째 항을 우선으로 내림차순하고, 같을 경우!! 1번째 항은 오름차순! 
    - list.sort(key=lambda x: x*4,reverse=True)
      - => 이런 식으로 람다와 reverse 같이 쓸 수 있음



- ~~인가?
  - 문자.isdigit() => True/False
  - 문자.isalpha() 
  - 문자.isalnum()  #알파벳+숫자


- 리스트
  - 리스트를 문자로 만들기 "".join(list)
  - 리스트를 역순으로 만들기 list[::-1]
  - 리스트를 역순 문자로 만들기 "".join(list[::-1]) 
    - =>  하나하나 문자 +=하는 것보다 시간적으로 더 효율적!

- list.sort()  vs sorted(iterable)
  - `sort()`는 리스트의 메서드로, 리스트 자체를 정렬합니다. 즉, 이 메서드를 호출한 리스트는 원본이 변경됩니다(in-place 정렬).
  - 반환 값은 `None`입니다. 따라서, `sort()` 메서드는 리스트를 직접 변경하고, 변경된 리스트를 반환하지 않습니다.
  - 오직 리스트에서만 사용할 수 있습니다.
  - `sorted()`는 내장 함수로, 어떤 반복 가능한 객체(iterable)에도 사용할 수 있으며, 정렬된 새로운 리스트를 반환합니다.
  - 원본 데이터는 변경되지 않습니다.
  - 리스트, 문자열, 튜플, 딕셔너리 등 다양한 반복 가능한 객체에 사용할 수 있습니다.


- 문자열
  - 문자.count("a")  # a 개수 찾아 반환 (없음 0개 )
  - 문자.find("a")  # a 위치 찾아 반환 (없으면 -1 반환)


- import sys
  - input = sys.stdin.readline()
    -  입력 시 뒤에 \n이 붙는다 
  - sys.maxsize
    - 2**63-1과 같은 값
    - 파이썬에서는 다른 언어와 다르게 크기 제한이 없긴 하다. 따라서 최솟값은 -sys.maxsize를 이용하자. 