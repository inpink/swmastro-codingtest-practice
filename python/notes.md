- [#[스택]](#[스택])
- [#[큐]](#[큐])
***

[14기]
- 1차
1) 구현
2) Brute Force/BackTracking/DFS/BFS
3) 조합, BFS
4) BFS (그리디)
5) SQL - 문자열(정규식)

- 2차
1) 스택
2) 그리디, 시뮬레이션
3) 구현, deque
4) 다익스트라/플로이드워셜
5) SQL - JOIN, UNION ALL


---

[13기]
- 1차
1) 구현
2) 빡구현
3) 조합
4) 정렬, 인덱싱
5) DFS

- 2차
1) 구현
2) brute force
3) Union-Find, BFS, DFS
4) DP


---

[12기]
- 1차
1) DFS
2) BRUTE FORCE
3) 투포인터
4) 구현
5) 분할정복
6) DP
7) 그리디

- 2차
1) DFS/BFS
2) 분할정복
3) 재귀


---

[11기]
- 1차
1) 구현
2) 그리디
3) BFUTE FORCE
4) BFS

- 2차
1) DP
2) BFS/DFS
3) UNION-FIND
4) 라인 스위핑
5) BRUTE FORCE
6) 정렬

***

최소한 기출된 모든 알고리즘은 구현 가능해야 함
+) 이분탐색?
+) MST(최소 신장 트리)?


***

[전략]
- 문제 푸는 시간 제한이 있기에 5번 먼저 풀고, 알고리즘 중 쉬운 거 먼저. 풀 문제 버릴 문제 잘 골라야 함.
- 문제 꼭 요약하고 정리하기. 예시 꼼꼼히 보기. SQL도 마찬가지.
- 어떤 알고리즘 사용할지 생각해보기
- 특히 n=1인 경우 등에 대해 테스트 케이스 꼭 추가로 만들기
- n=1인 경우에 대해서는 잘 생각하고 있어. 다만 "최댓값"에 대해 정확히 조사하자!!!! 이거 때문에 틀린 문제 '다리를 지나는 트럭'
- => 개선법. 미리 정해놓는 리스트의 크기를 변수값을 활용해서!
- 시간복잡도 제한은 빡빡하지 않은 편이므로 10초도 괜찮다 생각하고 정확하게 안전하게 구현하기!!
- 한 문제를 풀더라도 제대로 풀자! 이렇게 풀었는데 시간이 부족하다면 내가 부족한거다! 그렇다면 시간을 줄일 다른 방법을 찾아야 하는 거지! 문제 하나를 꼼꼼하지 않게 푼다고 되는 게 아니다!
- ⭐️ 중간에 break가 되는 경우, 따로 bool형 변수를 둬서 False인 경우 무조건 ans을 0으로 주는 코드를 추가하는 걸 고려하자
- 변수명은 가급적이면 중복적이게 쓰지 말자! 혹시 모르는 실수 발생을 방지하기 위해!
  컴파일러가 못 걸러준다. 단순 for문이더라도!
- 중첩 반복문 쓸 때 반복문 변수 주의하기

***

푼 문제
프로그래머스 고득점 kit 
백준 단계별

***

### [스택]
- 괄호 문제
- 키로거 문제
- 오큰수 
- * for문 돌리는 중간에 stack이 빌 수도 있으니까, stack이 비었을 경우에 입력한다는 조건 꼭 고려하기
https://school.programmers.co.kr/learn/courses/30/lessons/42584
=> 여기 있는 거 추후에 다시 보고 메모할 거 하기
- https://www.acmicpc.net/problem/10799 (풀이, 코드 한 번 간단히 보기)
- https://www.acmicpc.net/problem/1406

***

### [큐]
- 선입 선출 => 큐 생각하기!

***

### [연결리스트]

- 파이썬에서 연결리스트는 c언어처럼 직접 구현해줘야 한다. 
  따라서 시간이 소모될 수 있음을 고려해서 우선순위를 낮추든지 해야 할 듯
- 연결리스트에서 전체 순회는 while을 이용한다. 전체 길이를 알기 위해선 모두 순회를 해야하기 때문임
~~~
class Node:
    def __init__(self, val=0, next=None):
        self.val=val
        self.next=next
    
    def findOrDisplay(self, head):
        current = head  # 연결 리스트의 시작점
        while current is not None:
            # 현재 노드의 데이터 처리
            print(current.value)
            # 다음 노드로 이동
            current = current.next

head = Node(0)
nextNode = Node(1)
head.next=nextNode
~~~

***

### [해시]

- set 사용하여 중복 제거
- https://www.acmicpc.net/problem/1269
  - => set는 진짜 집합처럼 서로 빼기 가능함ㄷㄷ
***

### [조합]


***

### [Union-Find(분리 집합)]

분리 집합 :  분리된 집합
Union-Find : 분리된 집합 간의 합집합(Union)과 특정 원소가 속한 집합을 찾는(Find) 연산

⭐️ 코드 이해를 기반으로 외우기!!
아래 코드는, "x의 부모를 찾음과 동시에 지나가는 모든 길에서의 부모도 업데이트"
~~~
def find(x):
  if Vroot[x]!=x:
    Vroot[x] = find(Vroot[x])
  return Vroot[x]
~~~
***

[라이브러리]

⭐️ round는 내장 함수임!   
* 파이썬의 round는 특이하다. 0~4를 버리고 5~9를 올리는 사사오입 방식이 아님. 따라서 직접 구현해 쓸 것
~~~
만약 2자리 수에서 반올림하는 경우,
(3.15 - 3.1(버림 이용) >=0.05 라면 3.2(올림 이용))
(아니면 3.1(버림 이용))
=> 몇 자리 수에서 반올림하느냐에 따라 달라짐!
~~~
 
- import math
  - ceil : 올림
  - floor: 내림
  - fabs: 절대값
  - log(10,2) : log2(10)
  - sqrt(25) : 제곱근 구하기(5)

- 람다
  - max(iterable, key=lambda x:(dic[x], -x))
  - => 이렇게 여러 조건을 넣어줄 수도 있음! 
  - => dic의 key값이 큰 순으로, key값이 같다면 x가 작은 순으로 max 뽑음!!!
  - 2차원 리스트에서 2번째 값을 기준으로 최대값 구하기
    index, priot = max(dq, key=lambda x:x[1])
  - map(함수, 리스트)
    - 리스트에서 하나씩 꺼내 각각 함수를 적용시킨다
    - list(map(lambda x: x ** 2, range(5)))  
      [0, 1, 4, 9, 16]
  -  reduce(함수, 리스트)
    - 리스트에서 하나씩 꺼내서 함수 적용하고 누적시킴
    - reduce(lambda x, y: x + y, [0, 1, 2, 3, 4])
      10
    - from functools import reduce 필요!
    - 문자열 합치기를 reduce(lambda x,y:x+y,list)로 할 수 있긴 한데, 
      "".join(list)이 이미 있는지라.. 오히려 이거 쓰니까 시간초과뜸;; 확실하지 않으면 직접 구현하든지..
    - 왜냐하면 파이썬의 string도 "불변 객체"이기 때문에 매번 +=해주면 시간 문제 있을 수 있음
  - filter(함수, 리스트)
    - 리스트에서 하나씩 꺼내서 함수 적용 결과가 참인 경우에만 새로운 리스트에 담음
    - list(filter(lambda x: x < 5, range(10))) 
      [0, 1, 2, 3, 4]
  - sort(key=lambda x:len(x))
    - sort는 새로운 list를 반환하는게 아니라 기존의 리스트를 변경시킨다. 아무것도 반환하지 않는다!!!(None반환)
    - 람다로 sort도 가능! 다차원도 쉽고 빠르게 정렬 가능! 역순으로 해주고 싶다면 -만 붙여주면 됨!
    - 다차원 sort(key=lambda x:(-x[0], x[1])) 
      - => ⭐️2차원 리스트에서 0번째 항을 우선으로 내림차순하고, 같을 경우!! 1번째 항은 오름차순! 



- ~~인가?
  - 문자.isdigit() => True/False
  - 문자.isalpha() 
  - 문자.isalnum()  #알파벳+숫자


- 리스트
  - 리스트를 문자로 만들기 "".join(list)
  - 리스트를 역순으로 만들기 list[::-1]
  - 리스트를 역순 문자로 만들기 "".join(list[::-1]) 
    - =>  하나하나 문자 +=하는 것보다 시간적으로 더 효율적!

- list.sort()  vs sorted(iterable)
  - `sort()`는 리스트의 메서드로, 리스트 자체를 정렬합니다. 즉, 이 메서드를 호출한 리스트는 원본이 변경됩니다(in-place 정렬).
  - 반환 값은 `None`입니다. 따라서, `sort()` 메서드는 리스트를 직접 변경하고, 변경된 리스트를 반환하지 않습니다.
  - 오직 리스트에서만 사용할 수 있습니다.
  - `sorted()`는 내장 함수로, 어떤 반복 가능한 객체(iterable)에도 사용할 수 있으며, 정렬된 새로운 리스트를 반환합니다.
  - 원본 데이터는 변경되지 않습니다.
  - 리스트, 문자열, 튜플, 딕셔너리 등 다양한 반복 가능한 객체에 사용할 수 있습니다.



